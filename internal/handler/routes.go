// Code generated by goctl. DO NOT EDIT.
// goctl 1.8.3

package handler

import (
	"net/http"

	"github.com/zeromicro/go-zero/core/logx"
	"github.com/zgsm-ai/codebase-indexer/internal/svc"

	"github.com/zeromicro/go-zero/rest"
)

func RegisterHandlers(server *rest.Server, serverCtx *svc.ServiceContext) {
	// 1. 注册健康检查路由
	registerHealthCheckRoutes(server, serverCtx)
	
	// 2. 注册代理路由
	if serverCtx.Config.ProxyConfig != nil {
		// 使用智能代理处理器，根据请求头和配置自动选择转发策略
		proxyHandler := NewSmartProxyHandler(serverCtx.Config.ProxyConfig)
		logx.Infof("Using smart proxy handler with automatic routing strategy")
		
		// 注册代理处理器
		methods := []string{
			http.MethodGet,
			http.MethodPost,
			http.MethodPut,
			http.MethodDelete,
			http.MethodPatch,
			http.MethodHead,
			http.MethodOptions,
		}
		
		var routes []rest.Route
		if serverCtx.Config.ProxyConfig.DynamicPort {
			// 动态端口模式下，使用统一的路径前缀
			routes = make([]rest.Route, 0, len(serverCtx.Config.ProxyConfig.Routes)*len(methods))
			for _, routeConfig := range serverCtx.Config.ProxyConfig.Routes {
				for _, method := range methods {
					routes = append(routes, rest.Route{
						Method:  method,
						Path:    routeConfig.PathPrefix,
						Handler: http.HandlerFunc(proxyHandler.ServeHTTP),
					})
				}
			}
		} else {
			// 静态路由模式下，使用配置的路径前缀
			routes = make([]rest.Route, 0, len(serverCtx.Config.ProxyConfig.Routes)*len(methods))
			for _, routeConfig := range serverCtx.Config.ProxyConfig.Routes {
				for _, method := range methods {
					routes = append(routes, rest.Route{
						Method:  method,
						Path:    routeConfig.PathPrefix,
						Handler: http.HandlerFunc(proxyHandler.ServeHTTP),
					})
				}
			}
		}
		
		server.AddRoutes(routes)
	}
}

// registerHealthCheckRoutes 注册健康检查路由
func registerHealthCheckRoutes(server *rest.Server, serverCtx *svc.ServiceContext) {
	server.AddRoutes(
		[]rest.Route{
			{
				Method:  http.MethodGet,
				Path:    "/api/v1/proxy/health",
				Handler: proxyHealthCheckHandler(serverCtx),
			},
		},
		rest.WithPrefix("/codebase-indexer"),
	)
	
	// 如果启用了动态代理，注册动态代理健康检查路由
	if serverCtx.Config.ProxyConfig != nil && serverCtx.Config.ProxyConfig.DynamicPort {
		server.AddRoutes(
			[]rest.Route{
				{
					Method:  http.MethodGet,
					Path:    "/api/v1/dynamic-proxy/health",
					Handler: dynamicProxyHealthCheckHandler(serverCtx),
				},
			},
			rest.WithPrefix("/codebase-indexer"),
		)
	}
}

// dynamicProxyHealthCheckHandler 动态代理健康检查处理器
func dynamicProxyHealthCheckHandler(serverCtx *svc.ServiceContext) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		if serverCtx.Config.ProxyConfig != nil && serverCtx.Config.ProxyConfig.DynamicPort {
			dynamicHandler := NewDynamicProxyHandler(serverCtx.Config.ProxyConfig)
			dynamicHandler.HealthCheck(w, r)
			return
		}

		http.Error(w, "Dynamic proxy not configured", http.StatusNotImplemented)
	}
}